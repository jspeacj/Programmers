package Programmers.Level1;

import java.util.Arrays;
import java.util.Collections;

public class PCCEPastExamQuestions10_Park {
    public static void main(String[] args) {
        /*
            [PCCE 기출문제] 10번 / 공원
            문제 설명
            지민이는 다양한 크기의 정사각형 모양 돗자리를 가지고 공원에 소풍을 나왔습니다.
            공원에는 이미 돗자리를 깔고 여가를 즐기는 사람들이 많아 지민이가 깔 수 있는 가장 큰 돗자리가 어떤 건지 확인하려 합니다.
            예를 들어 지민이가 가지고 있는 돗자리의 한 변 길이가 5, 3, 2 세 종류이고,
            사람들이 다음과 같이 앉아 있다면 지민이가 깔 수 있는 가장 큰 돗자리는 3x3 크기입니다.

            10.jpg

            지민이가 가진 돗자리들의 한 변의 길이들이 담긴 정수 리스트 mats,
            현재 공원의 자리 배치도를 의미하는 2차원 문자열 리스트 park가 주어질 때
            지민이가 깔 수 있는 가장 큰 돗자리의 한 변 길이를 return 하도록
            solution 함수를 완성해 주세요. 아무런 돗자리도 깔 수 없는 경우 -1을 return합니다.

            제한사항
            1 ≤ mats의 길이 ≤ 10
            1 ≤ mats의 원소 ≤ 20
            mats는 중복된 원소를 가지지 않습니다.

            1 ≤ park의 길이 ≤ 50
            1 ≤ park[i]의 길이 ≤ 50
            park[i][j]의 원소는 문자열입니다.
            park[i][j]에 돗자리를 깐 사람이 없다면 "-1", 사람이 있다면 알파벳 한 글자로 된 값을 갖습니다.

            입출력 예
             mats	                                                    park
            [5,3,2]	[["A", "A", "-1", "B", "B", "B", "B", "-1"], ["A", "A", "-1", "B", "B", "B", "B", "-1"], ["-1", "-1", "-1", "-1", "-1", "-1", "-1", "-1"], ["D", "D", "-1", "-1", "-1", "-1", "E", "-1"], ["D", "D", "-1", "-1", "-1", "-1", "-1", "F"], ["D", "D", "-1", "-1", "-1", "-1", "E", "-1"]]
            result 3
            입출력 예 설명
            입출력 예 #1
            지문과 동일합니다.
            cpp를 응시하는 경우 리스트는 배열과 동일한 의미이니 풀이에 참고해주세요.
            ex) 번호가 담긴 정수 리스트 numbers가 주어집니다. => 번호가 담긴 정수 배열 numbers가 주어집니다.
            java를 응시하는 경우 리스트는 배열, 함수는 메소드와 동일한 의미이니 풀이에 참고해주세요.
            ex) solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. => solution 메소드가 올바르게 작동하도록 한 줄을 수정해 주세요.
         */
        /* TC 1 result : 3 */
        int[] mats = {5,3,2};
        String[][] park = {{"A", "A", "-1", "B", "B", "B", "B", "-1"}, {"A", "A", "-1", "B", "B", "B", "B", "-1"}, {"-1", "-1", "-1", "-1", "-1", "-1", "-1", "-1"}, {"D", "D", "-1", "-1", "-1", "-1", "E", "-1"}, {"D", "D", "-1", "-1", "-1", "-1", "-1", "F"}, {"D", "D", "-1", "-1", "-1", "-1", "E", "-1"}};

        /*
            내용 정리 :
            공원의 총길이는 가로 및 세로 모두 최대 50
            필요한 리턴 값은 해당 매트를 세팅할 좌표까지 필요한 것이 아닌 지민이 가지고 있는 매트들 중,
            설치 가능한 한 변의 최대 값만 필요

            초기 방안 1)
            1. 공원의 이차원 배열과 동일한 크기의 파라미터를 추가해둔다. (기본 값 : 0)
            2. 각 x, y 좌표를 기준 반복문을 수행하면서 우측 및 좌표 기준 방향으로 만들 수 있는 정사각형의 한변의 길이를 해당 시작 좌표에 반영한다.
            => 시작지점에 -1이 아닌 다른 값(이미 자리가 존재)할 경우 수행 없이 0으로 세팅 후 continue
            => 2.1 정사각형일 경우 => 체크 값을 1 증가 시키며, 체크한 좌표 값 이후 우측 및 아래 좌표에 자리가 존재할 경우(-1) 정사각형인지 체크하는 메서드를 계속 호출한다.
            => 2.2 정사각형이 아닐 경우 => 체크 값을 해당 시작점 좌표에 세팅한 후 다음 좌표 값으로 이동한다.
            3. 모든 반복문 수행 후 반복문을 수행하여 지민이 가지고 있는 돗자리의 한변과 일치하는 값 중, 설치 가능한 돗자리의 가장 큰 값을 반환한다.

            방안 2)
            개선점 : 위 1번 내용과 유사한 방식이지만, 1번에 경우 모든 경우의 수를 기준으로 체크하기 떄문에 성능상 좋지 못한 방안인것으로 판단.
            이에 문제에서 주어진 지민이 가지고 있는 매트의 길이가 담겨진 배열을 이용하여 특정 케이스일때만 체크할 수 있도록 방안 개선
            1. 지민이 가지고 있는 매트 배열 mats를 내림차순으로 정렬한다.
            2. 지민이 가지고 있는 mats 반복문을 수행하여 공원에 해당하는 x, y 좌표를 기준 정사각형에 해당하는 공간이 존재하는지 체크한다.
            3. 체크 당시 해당 mats 값에 해당하는 정사각형이 만족되지 않을 경우 다음 좌표를 기준으로 체크하는 식으로 반복문을 수행한다.
            4.1 정사각형에 해당하는 값이 존재할 경우 => 해당 값을 반환하며 종료
            4.2 정사각형에 해당하는 값이 존재하지 않을 경우 => mats의 다음 값을 기준으로 다시 체크
            4.3 최종적으로 mats에 값들 중 정사각형을 만들 수 있는 값이 하나도 존재하지 않을 경우 => -1 반환하여 종료
        */

        int result = -1;
        Integer[] IntegerMats = Arrays.stream(mats).boxed().toArray(Integer[]::new);
        Arrays.sort(IntegerMats, Collections.reverseOrder());
        for (int num : IntegerMats) {
            if (chkSquare(park, num)) {
                result = num;
                break;
            }
        }

        System.out.println(result);
    }

    public static boolean chkSquare(String[][] park, int num) {
        for (int i = 0; i < park.length; i++) {
            for (int j = 0; j < park[i].length; j++) {
                if (!"-1".equals(park[i][j])) continue; // 비어있는 공간이 아닐 경우 스킵
                if (i + num > park.length) continue; // 현재 시작점 좌표 기준 필요한 공간을 합친 길이가 행의 길이를 초과할 경우 체크할 필요가 없기 때문에 종료
                if (j + num > park[i].length) continue; // 현재 시작점 좌표 기준 필요한 공간을 합친 길이가 열의 길이를 초과할 경우 체크할 필요가 없기 때문에 종료

                if (chkSpace(park, i, j, num)) { // 시작 좌표 기준 체크하며, 지민의 돗자리를 세팅할 수 있는 공간이 존재하는지 체크
                    return true; // 한변의 길이가 num인 돗자리를 세팅할 수 있는 공간이 존재하기 때문에 해당 메서드 종료
                }
            }
        }

        return false;
    }

    public static boolean chkSpace(String[][] park, int i, int j, int num) {
        for (int row = i; row < i + num; row++) { // 시작 행,열 기준 돗자리 한변의 길이인 num까지 체크
            for (int col = j; col < j + num; col++) {
                if (!"-1".equals(park[row][col])) { // 한 곳이라도 다른 사람의 돗자리 영역이 존재할 경우 돗자리를 세팅할 수 없기 떄문에 세팅 불가로 종료
                    return false;
                }
            }
        }

        return true;
    }
}
